<analytic>
	<analytic>getBars</analytic>
	<code_text>{[args] 
    args[`API]:`getBars;

    args:.daas.util.adjustParams[`getBars;args];

    args[`rackTemporalWhereClause]:();
    args[`rackStart]:args`startTime;
    args[`rackEnd]:(args`endTime)-00:00:00.000000001;
    args[`symCol]:.daas.wc.getSymCol args`idType;
    args:.daas.util.applyBarAssetClassTableName[args];
    
    colClause:.daas.util.genBarColClause[args];
    // Currently getBars on disk tables have "time" as their timestamp col
    // regardless of whether the bars were generated by insertTime or exchangeTime
    byClause:.daas.util.genByDict[`.rack.timeRackList;`time;args`symCol];
    args[`timeRack]:$[`~args`granularityUnit;
        .rack.timeRackList:enlist args`rackStart;
        .rack.timeRackList:.daas.util.genByTimeRack[args]
        ];

    res:.daas.util.getBarsCorAx[args;colClause;byClause];
    res:.daas.util.rackTable[res;args];
    res:.daas.util.convertOnDiskTZtoOutboundTZ[args;![res;();0b;(enlist`time)!enlist`time]];
    res:.daas.util.joinFills[res;args`fill;`sym];
    res:.daas.util.sortCols[res;args];
    res:.daas.util.customSymbologyMappingSwapBack[res;args];
    
    res:$[args[`granularityUnit]~`day;
        `date xcols delete time from update date:time.date from res;
        res
        ];
    
    0!res 
    }</code_text>
	<description>Build dictionary of syms and qualifiers to group by.
Build dictionary of columns to select with aggregations.
Select from server, applying created dictionaries and conditions passed in params dictionary.
Concatenate qualifiers.
Select from result table where entries are valid based on concatenated qualifiers.</description>
	<dictionaryparams>0</dictionaryparams>
	<typ>Analytic</typ>
	<private>0</private>
	<returntype></returntype>
	<returndata></returndata>
	<defaultconnection></defaultconnection>
	<alias>getBars</alias>
	<analytictype>polling</analytictype>
	<returndescription></returndescription>
	<param>
		<parameter>args</parameter>
		<default>
			<dictkey>
				<name>symList</name>
				<datatype>Symbol[]</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>dataType</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>assetClass</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>startDate</name>
				<datatype>Date</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>endDate</name>
				<datatype>Date</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>inputTimeZone</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>outputTimeZone</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>timeZone</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>startTime</name>
				<datatype>Time</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>endTime</name>
				<datatype>Time</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>temporality</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>time</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>analytics</name>
				<datatype>Symbol[]</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>granularityUnit</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>true</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>granularity</name>
				<datatype>Integer</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>fill</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>applyCanCor</name>
				<datatype>Boolean</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>sortCols</name>
				<datatype>Symbol[]</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>trackSym</name>
				<datatype>Boolean</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>idType</name>
				<datatype>Symbol</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
			<dictkey>
				<name>adjustCorAx</name>
				<datatype>Boolean</datatype>
				<default></default>
				<isrequired>false</isrequired>
				<description></description>
			</dictkey>
		</default>
		<description>the time parameters</description>
		<required>1</required>
		<datatype>Dict</datatype>
	</param>
	<analyticgroup>daasQR</analyticgroup>
	<analyticgroup>daasQS</analyticgroup>
</analytic>
